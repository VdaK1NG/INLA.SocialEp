---
title: "Usage Example"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Usage Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<div style="text-align: justify">

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction



```{r setup}
library("INLA.SocialEp")
```

# Understanding the inputs

<b>DISCLAIMER:</b> Observed and expected values have to be given in an specific order. Consider n the number of areas, the first n values (1:n) of the obs (exp) should be the ones belonging to the FIRST level (the first position of the <b>lev.fac1</b> vector argument) of the FIRST factor (the first position of the <b>fac.names</b> vector argument) and to the FIRST level (the first position of the <b>lev.fac2</b> vector argument) of the SECOND factor (the second position of the <b>fac.names</b> vector argument). The n following values ((n+1):2n) of the obs (exp) should be the ones belonging to the FIRST level (the first position of the <b>lev.fac1</b> vector argument) of the FIRST factor (the first position of the fac.names</b> vector argument) and to the SECOND level (the second position of the <b>lev.fac2</b> vector argument) of the SECOND factor (the second position of the <b>fac.names</b> vector argument).<br/>
<br/>
The n following values ((2n+1):3n) of the obs (exp) should be the ones belonging to the SECOND level (the second position of the <b>lev.fac1</b> vector argument) of the FIRST factor (the first position of the <b>fac.names</b> vector argument) and to the FIRST level (the first position of the <b>lev.fac2</b> vector argument) of the SECOND factor (the second position of the <b>fac.names</b> vector argument).<br/>
<br/>
The n following values ((3n+1):4n) of the obs (exp) should be the ones belonging to the SECOND level (the second position of the <b>lev.fac1</b> vector argument) of the FIRST factor (the first position of the <b>fac.names</b> vector argument) and to the SECOND level (the second position of the <b>lev.fac2</b> vector argument) of the SECOND factor (the second position of the <b>fac.names</b> vector argument).<br/>
<br/>
The first n values are O1, the second n values are O2, the third n values are O3 and the last n values are O4.

```{r}
sec.nb <- spdep::poly2nb(us_county_23, snap=0.0000005)
spdep::nb2INLA("MapGraph", sec.nb)
graph_states <- INLA::inla.read.graph("MapGraph")
```


# Customizing parameters

There are three mainly aspects regarding the modelization and post-processing that can be modified by the user:

  * **Prior Specification**:
  * **Shared Copies in INLA**:
  * **Saving Options**:

## Prior specification

## Shared Copies in INLA

## Saving Inputs

# Modelling

## Understanding the output

## High Dimension Datasets

In case that you are working with a high dimensional datasets where the number of areas is high, we advise running the `inla.SpANOVA.2x2` with the option `save.mod.data=TRUE`, which will save all the necessary information to run the desired specification afterwards, and all the saving inputs options as `FALSE`. This will allow you to run through all the possible configurations without saving the complete results, which should speed things up and avoid saving undesired results.

```{r chunk2}
ResMod <- inla.SpANOVA.2x2(
  obs = c(sp_object_sim$OBS_M6_SIM_G1_v3, sp_object_sim$OBS_M6_SIM_G2_v3, sp_object_sim$OBS_M6_SIM_G3_v3, sp_object_sim$OBS_M6_SIM_G4_v3), 
  exp = c(sp_object_sim$EXP, sp_object_sim$EXP, sp_object_sim$EXP, sp_object_sim$EXP), 
  gr = graph_states,
  fac.names = c("F1", "F2"),
  lev.fac1 = c("F1L1", "F1L2"),
  lev.fac2 = c("F2L1", "F2L2"),
  scale.mod = FALSE,
  sp.prior = "pc.prec",
  pc.prec.val = c(1, 0.01),
  sp.copy.fixed = FALSE,
  save.res=FALSE, 
  save.random=FALSE,
  save.hyper=FALSE, 
  save.mod.data=TRUE
  )
```

After that we can re-run the model of choice, which in this case is BLABLA. We are free to change some of the parameters now, so we will try the sdunif prior, and setting `scale.mod=TRUE` and `sp.copy.fixed=TRUE`:

```{r chunk3}
ResMod_fin <- inla.rerun.SpANOVA(
  SpANOVA_obj = ResMod, 
  n_mod = 20, 
  gr = graph, 
  scale.mod = TRUE, 
  sp.prior = "sdunif", 
  sp.copy.fixed = TRUE, 
  verbose.INLA = FALSE
)
```

Since it is an INLA object we can run a summary:

```{r chunk4}
summary(ResMod_fin)
```

We can also check the spatial effects adjusted:

```{r chunk5}
plot.SpANOVA(
  obj=ResMod,
  obj_type="SpANOVA",
  fill_by="Spatial",
  n_mod=20,
  sp_object=sp_object_sim,
  breaks=c(-3, -2, -1, -0.5, -0.1, 0.1, 0.5, 1, 2, 3),
  fil_scale=c("#133BF2", "#7189F7", "#FFFFFF", "#FF867A", "#FF2F1B"),
  scale_name="Values",
  sp_null=0.125,
  legend.position="right",
  ncol_fig=2
)
```


As well as the adjusted relative risks:

```{r chunk6}
plot.SpANOVA(
  obj=ResMod,
  obj_type="SpANOVA",
  fill_by="RR",
  n_mod=20,
  sp_object=sp_object_sim,
  breaks=c(0, 0.5, 0.9, 1.1, 2, 3),
  fil_scale=c("#133BF2", "#7189F7", "#FFFFFF", "#FF867A", "#FF2F1B"),
  scale_name="Values",
  sp_null=0.125,
  legend.position="right",
  ncol_fig=2
)
```

# References


***

